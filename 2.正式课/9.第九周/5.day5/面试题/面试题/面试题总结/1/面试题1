##易车
###笔试:
1.引入css样式的方式有哪几种？
```
四中方式,重点注意权重和导入@import问题
将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，<style>标记也是写在<head>标记中，使用的语法如下：
<style type="text/css">
@import"mystyle.css"; 此处要注意.css文件的路径
</style>
导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。
```
2.写出position的所有值?
```
1.absolute:	
   生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。
元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
2.fixed:	
   生成绝对定位的元素，相对于浏览器窗口进行定位。
元素的位置通过 "left", "top", "right" 以及 "bottom" 属性进行规定。
3.relative:	
   生成相对定位的元素，相对于其正常位置进行定位。
因此，"left:20" 会向元素的 LEFT 位置添加 20 像素。
4.static:
   默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。
5.inherit:	
   规定应该从父元素继承 position 属性的值。
```
3.box-sizing的属性值content-box 和 border-box的计算方式?
```
css3 box-sizing属性
box-sizing属性可以为三个值之一：content-box（default），border-box，padding-box。
content-box: border和padding不计算入width之内
padding-box: padding计算入width内
border-box: border和padding计算入width之内，其实就是怪异模式了~
ie8+浏览器支持content-box和border-box；
ff则支持全部三个值。

使用时：
-webkit-box-sizing: 100px; // for ios-safari, android
-moz-box-sizing:100px; //for ff
box-sizing:100px; //for other
```
4.写出三列布局的css，左侧与右侧固定200px, 中间自适应
5.用box-shadow 写出单边上阴影效果（阴影半径与模糊半径不限）
6.一下代码输出结果
```
var a = {n:4};
var b = a;
b.x = a = {n: 10};
console.log(a.x);//undefined
console.log(b.x);//{n:10}
```
7.cookie、sessionStorage、localStorage的区别
```
1.cookie:存储在用户本地终端上的数据。有时也用cookies，指某些网站为了辨别用户身份，进行session跟踪而存储在本地终端上的数据，通常经过加密。一般应用最典型的案列就是判断注册用户是否已经登过该网站。

2.HTML5 提供了两种在客户端存储数据的新方法：两者都是仅在客户端（即浏览器）中保存，不参与和服务器的通信；

localStorage - 没有时间限制的数据存储,第二天、第二周或下一年之后，数据依然可用。

如何创建和访问 localStorage：
<script type="text/javascript">
localStorage.lastname="Smith";
document.write(localStorage.lastname);
</script>

下面的例子对用户访问页面的次数进行计数：

<script type="text/javascript">
if (localStorage.pagecount){
  localStorage.pagecount=Number(localStorage.pagecount) +1;
  }
else{
  localStorage.pagecount=1;
  }
document.write("Visits "+ localStorage.pagecount + " time(s).");
</script>

sessionStorage - 针对一个 session 的数据存储,当用户关闭浏览器窗口后，数据会被删除。

创建并访问一个 sessionStorage：
<script type="text/javascript">
  sessionStorage.lastname="Smith";
  document.write(sessionStorage.lastname);
</script>

下面的例子对用户在当前 session 中访问页面的次数进行计数：
<script type="text/javascript">
if (sessionStorage.pagecount){
  sessionStorage.pagecount=Number(sessionStorage.pagecount) +1;
  }
else{
  sessionStorage.pagecount=1;
  }
document.write("Visits "+sessionStorage.pagecount+" time(s) this session.");
</script>

sessionStorage 、localStorage 和 cookie 之间的区别
共同点：都是保存在浏览器端，且同源的。

区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。

而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。

数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。

作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。
```

###问答:
1. 自我介绍
2. 你们使用h5做的登录么，和用native做登录有什么区别?
```
优势：
   1.H5可跨平台使用，开发成本相对更低，一个产品经理+前端+设计+后台就能搞定；App则需适配iOS、安卓等不同平台进行设计和开发，至少需要iOS工程师+Android工程师+PM+前端+设计+后台，开发成本高出1/3甚至更多。
   2.H5可随时上线就更新版本，适合快速迭代，且试错成本低。
.一个功能做好了立马就能上线，一天更新几十次都毫无压力；App则需要用户主动下载更新，主流的就是iOS，Android、windows仨平台，不同平台运营推广的玩法还不一样，分发和运维成本很高。
   3.而且一个版本的功能出来，虽然很快就能做出其中一部分让内部人员体验。但等我们全部做完了，可能已经过去一周了。然后提交给平台做审核，又要等一阵，再找个好日子发布，三周就过去了。同时，我们如果又做出了更多新的功能，优化了细节，再修复几个bug等等，用户却也只能再等几十天才能体验到。
   4.H5可以轻量的触达用户，提供更便捷的服务。
相比在桌面上下一大堆App，在微信的入口或者浏览器上，用户只需点开链接就可以获取我们所提供的服务。有更高的使用时长及导流能力，基于公众号的运营和推广可以快速的触达用户。
劣势：
   1.H5—>App的转化强依赖于浏览器，要把用户真正留存在自己的产品中需要进一步的转化；而APP可以内嵌H5，直接在应用内即可打开并与H5进行转化。
H5目前基本无法将数据存储在本地，依赖实时性数据，网络状态不好的时候卡到哭。
每当用户需要上传数据，比如输入，选择，传照片等，页面的延迟会影响使用的流畅性；而APP可以本地存储，运行速度更快，更省流量，可离线操作或者访问本地资源。
H5性能相对较低。
   2.对于复杂的交互，比如3D特效，频繁的输入输出等等，即使实现了，在用户体验上也要减分。比如在Native App上，一个类似页面滑动切换的效果，基本不会感受到延迟，你手指只要开始滑动，页面就无缝的跟着滑动，但在Web上，大家应该都经常看微信里的各种H5的花哨分享页面吧，那滑动流畅吗？
   3.对于Web App 和 Native App跟H5这三者最终该如何选择，我们还需要考虑，企业的具体产品需求，产品的核心功能，辅助功能，配合运营需求，应用场景等方面的影响。所有的产品都是有了场景才会有体验，针对体验才能有的放矢。再结合他们之间的的优劣情况，我们选择起来就显得比较简单了。
```
3. 你们平时开发怎么模拟数据的?
```
如果是小的简单请求的问题,直接在本地创建一个JSON数据,起本地服务就可以了,如果是本地跑通后开始线下测试,后台就会开一测试环境,给你接口(约定数据结构,约定数据字段名称,模拟数据传输场景)
一般采用moco数据
可以看:http://www.jianshu.com/p/dd17342d497b
```
4. 你们现在开发主要用了哪些技术?
```
谁再说HTML,CSS,JS.JQ,node ,vue...那就拜拜了
现在用Gulp vue - webpack 搭建项目框架结构,引入各种前端插件等
后台使用node环境,以及各种包模块,有很多第三方模块我也没怎么用过,也喜欢琢磨一下
或者使用:webpack、react、redux、es6 技术栈等
```
5. 用的vue哪个版本? vue的组件之间是如何交互的, 几种方式.
6. react之前版本是有双向绑定的，如何实现的？那vue的双向绑定原理呢?
7. gulp和webpack之间的区别(也提到了和grunt的区别)
```
好多人都问起这个问题,根据我自己使用他俩的情况,我是这么感觉的,这两个构建工具功能上有很多重叠的地方，可以单独使用，也可一起用,如果做一下简单的vue或react的单页应用，webpack也就够用,稍微大型的项目一般俩个一起用.
区别的话 
1.gulp强调的是前端开发的工作流程，我们可以通过配置一系列的task，定义task处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些task，从而构建项目的整个前端开发流程。核心是 task runner
2.webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。核心是: module bundle
我们在gulp进行项目构建的时候，以前策略是将所有js打包为一个文件，所有css打包为一个文件。然后每个页面都将只加载一个js和一个css,也就是我们通常所说的 ==all in one== 打包模式。这样做的目的就是减少http请求。这个方案对于简单的前端项目来说的非常实用。因为通常页面依赖的js,css并不会太大，通过压缩和gzip等方法更加减小了文件的体积。
但是随着东西的增多,对性能要求也随之而来,不仅要请求合并，还要按需加载，我要模块化开发，还要自动监听文件更新，支持图片自动合并....
对于pc端应用来说，性能往往不是最突出的问题，因为pc端的网速，浏览器性能都有比较好,对于wap端来说，限制于手机的慢网速（仍然有很多用不上4g，wifi的人），对网站的性能要求就比较苛刻了,最大的问题按需加载和请求合并的权衡。
    1.通过工具分析出前端静态文件依赖表
    2.页面通过模块化工具加载入口文件，并将所依赖的所有文件合并为combo请求。
    3.后端返回combo文件，浏览器将模块缓存起来，跳页面的时候执行步骤2，只请求没有缓存过的文件。
如此通过依赖分析和后端combo实现了按需加载和请求合并。
这种实现方式的缺陷就是需要后端的支持，如果前端团队本身不是自己实现的后端路由层，需要后端同学加以配合，就需要更多沟通成本。
在没有后端支持的情况下，很难实现按需加载和请求合并。
webpack可以说是一个大而全的前端构建工具。它实现了模块化开发和静态文件处理两大问题。
我们可以用webpack处理js文件的合并压缩。其他任务也可以交给gulp
```
8. websocket和http协议之间的区别?
```
HTTP协议为单向协议，即浏览器只能向服务器请求资源，服务器才能将数据传送给浏览器，而服务器不能主动向浏览器传递数据。分为长连接和短连接，短连接是每次http请求时都需要三次握手才能发送自己的请求，每个request对应一个response；长连接是短时间内保持连接，保持TCP不断开，指的是TCP连接。

WebSocket解决客户端发起多个http请求到服务器资源浏览器必须要经过长时间的轮询问题。
一种双向通信协议，在建立连接后，WebSocket服务器和Browser/UA都能主动的向对方发送或接收数据，就像Socket一样，不同的是WebSocket是一种建立在Web基础上的一种简单模拟Socket的协议；     
WebSocket需要通过握手连接，类似于TCP它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。
WebSocket在建立握手连接时，数据是通过http协议传输的，“GET/chat HTTP/1.1”，这里面用到的只是http协议一些简单的字段。但是在建立连接之后，真正的数据传输阶段是不需要http协议参与的。

socket是对TCP/IP协议的封装，本身并不是协议，而是一个调用接口(API)，通过Socket，我们才能使用TCP/IP。
四层，分别为应用层（Telnet、FTP和Email等）、运输层（TCP、UDP）、网络层（IP、ICMP、IGMP等）和链路层（设备驱动程序）
三次握手完毕后，客户端与服务器才正式开始传送数据
四次挥手后断开连接
套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认
TCP：面向连接，通过三次握手建立连接，通讯完成时要拆除连接，只能端到端传输
```
9. 你了解过闭包么？
10. 你有什么想问我的么

###二面:
1. 输入url，页面展示出来，用的什么协议? http协议属于那一层? 7层。
2. 进程和线程的区别.
3. 从输入一个url，到也没展示，中间发生了什么?
4. 秒杀时，如何保证当库存只剩下10个的时候， 能正常分配?
5. 让你来设计的话，如何能把表单安全的提交过去。
6. 线上代码经常更新，再次上线的时候，如何保证代码是新的，？不读缓存
