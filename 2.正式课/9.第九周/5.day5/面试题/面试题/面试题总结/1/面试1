<!DOCTYPE html><html><head><title>易车</title><meta charset='utf-8'><link href='https://dn-maxiang.qbox.me/res-min/themes/marxico.css' rel='stylesheet'><style>
.note-content  {font-family: 'Helvetica Neue', Arial, 'Hiragino Sans GB', STHeiti, 'Microsoft YaHei', 'WenQuanYi Micro Hei', SimSun, Song, sans-serif;}

</style></head><body><div id='preview-contents' class='note-content'>
                        
                    



<h2 id="易车">易车</h2>



<h3 id="笔试">笔试:</h3>

<p>1.引入css样式的方式有哪几种？</p>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs xml"><span class="hljs-comment line-number">1.</span>四中方式,重点注意权重和导入@import问题<br><span class="hljs-comment line-number">2.</span>将一个独立的.css文件引入HTML文件中，导入式使用CSS规则引入外部CSS文件，<span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="xml">标记也是写在<span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span>标记中，使用的语法如下：<br><span class="hljs-comment line-number">3.</span><span class="hljs-tag">&lt;<span class="hljs-name">style</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/css"</span>&gt;</span><span class="css"><br><span class="hljs-comment line-number">4.</span>@<span class="hljs-keyword">import</span>"<span class="hljs-keyword">mystyle</span>.<span class="hljs-keyword">css</span>"; 此处要注意<span class="hljs-selector-class">.css</span>文件的路径<br><span class="hljs-comment line-number">5.</span></span></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br><span class="hljs-comment line-number">6.</span>导入式会在整个网页装载完后再装载CSS文件，因此这就导致了一个问题，如果网页比较大则会儿出现先显示无样式的页面，闪烁一下之后，再出现网页的样式。这是导入式固有的一个缺陷。<br></code></pre>

<p>2.写出position的所有值?</p>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs stylus"><span class="hljs-comment line-number">1.</span><span class="hljs-number">1</span><span class="hljs-selector-class">.absolute</span>: <br><span class="hljs-comment line-number">2.</span>   生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。<br><span class="hljs-comment line-number">3.</span>元素的位置通过 <span class="hljs-string">"left"</span>, <span class="hljs-string">"top"</span>, <span class="hljs-string">"right"</span> 以及 <span class="hljs-string">"bottom"</span> 属性进行规定。<br><span class="hljs-comment line-number">4.</span><span class="hljs-number">2</span><span class="hljs-selector-class">.fixed</span>:    <br><span class="hljs-comment line-number">5.</span>   生成绝对定位的元素，相对于浏览器窗口进行定位。<br><span class="hljs-comment line-number">6.</span>元素的位置通过 <span class="hljs-string">"left"</span>, <span class="hljs-string">"top"</span>, <span class="hljs-string">"right"</span> 以及 <span class="hljs-string">"bottom"</span> 属性进行规定。<br><span class="hljs-comment line-number">7.</span><span class="hljs-number">3</span><span class="hljs-selector-class">.relative</span>: <br><span class="hljs-comment line-number">8.</span>   生成相对定位的元素，相对于其正常位置进行定位。<br><span class="hljs-comment line-number">9.</span>因此，<span class="hljs-string">"left:20"</span> 会向元素的 LEFT 位置添加 <span class="hljs-number">20</span> 像素。<br><span class="hljs-comment line-number">10.</span><span class="hljs-number">4</span><span class="hljs-selector-class">.static</span>:<br><span class="hljs-comment line-number">11.</span>   默认值。没有定位，元素出现在正常的流中（忽略 <span class="hljs-attribute">top</span>, bottom, left, right 或者 z-index 声明）。<br><span class="hljs-comment line-number">12.</span><span class="hljs-number">5</span><span class="hljs-selector-class">.inherit</span>:  <br><span class="hljs-comment line-number">13.</span>   规定应该从父元素继承 <span class="hljs-attribute">position</span> 属性的值。<br></code></pre>

<p>3.box-sizing的属性值content-box 和 border-box的计算方式?</p>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs maxima"><span class="hljs-comment line-number">1.</span>css3 <span class="hljs-built_in">box</span>-sizing属性<br><span class="hljs-comment line-number">2.</span><span class="hljs-built_in">box</span>-sizing属性可以为三个值之一：<span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>（default），<span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>，padding-<span class="hljs-built_in">box</span>。<br><span class="hljs-comment line-number">3.</span><span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>: <span class="hljs-built_in">border</span>和padding不计算入<span class="hljs-built_in">width</span>之内<br><span class="hljs-comment line-number">4.</span>padding-<span class="hljs-built_in">box</span>: padding计算入<span class="hljs-built_in">width</span>内<br><span class="hljs-comment line-number">5.</span><span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>: <span class="hljs-built_in">border</span>和padding计算入<span class="hljs-built_in">width</span>之内，其实就是怪异模式了~<br><span class="hljs-comment line-number">6.</span>ie8+浏览器支持<span class="hljs-built_in">content</span>-<span class="hljs-built_in">box</span>和<span class="hljs-built_in">border</span>-<span class="hljs-built_in">box</span>；<br><span class="hljs-comment line-number">7.</span>ff则支持全部三个值。<br><span class="hljs-comment line-number">8.</span><br><span class="hljs-comment line-number">9.</span>使用时：<br><span class="hljs-comment line-number">10.</span>-webkit-<span class="hljs-built_in">box</span>-sizing: 100px; // <span class="hljs-keyword">for</span> ios-safari, android<br><span class="hljs-comment line-number">11.</span>-moz-<span class="hljs-built_in">box</span>-sizing:100px; //<span class="hljs-keyword">for</span> ff<br><span class="hljs-comment line-number">12.</span><span class="hljs-built_in">box</span>-sizing:100px; //<span class="hljs-keyword">for</span> other<br></code></pre>

<p>4.写出三列布局的css，左侧与右侧固定200px, 中间自适应 <br>
5.用box-shadow 写出单边上阴影效果（阴影半径与模糊半径不限） <br>
6.一下代码输出结果</p>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs javascript"><span class="hljs-comment line-number">1.</span><span class="hljs-keyword">var</span> a = {<span class="hljs-attr">n</span>:<span class="hljs-number">4</span>};<br><span class="hljs-comment line-number">2.</span><span class="hljs-keyword">var</span> b = a;<br><span class="hljs-comment line-number">3.</span>b.x = a = {<span class="hljs-attr">n</span>: <span class="hljs-number">10</span>};<br><span class="hljs-comment line-number">4.</span><span class="hljs-built_in">console</span>.log(a.x);<span class="hljs-comment">//undefined</span><br><span class="hljs-comment line-number">5.</span><span class="hljs-built_in">console</span>.log(b.x);<span class="hljs-comment">//{n:10}</span><br></code></pre>

<p>7.cookie、sessionStorage、localStorage的区别</p>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs xml"><span class="hljs-comment line-number">1.</span>1.cookie:存储在用户本地终端上的数据。有时也用cookies，指某些网站为了辨别用户身份，进行session跟踪而存储在本地终端上的数据，通常经过加密。一般应用最典型的案列就是判断注册用户是否已经登过该网站。<br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span>2.HTML5 提供了两种在客户端存储数据的新方法：两者都是仅在客户端（即浏览器）中保存，不参与和服务器的通信；<br><span class="hljs-comment line-number">4.</span><br><span class="hljs-comment line-number">5.</span>localStorage - 没有时间限制的数据存储,第二天、第二周或下一年之后，数据依然可用。<br><span class="hljs-comment line-number">6.</span><br><span class="hljs-comment line-number">7.</span>如何创建和访问 localStorage：<br><span class="hljs-comment line-number">8.</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><br><span class="hljs-comment line-number">9.</span>localStorage.lastname=<span class="hljs-string">"Smith"</span>;<br><span class="hljs-comment line-number">10.</span><span class="hljs-built_in">document</span>.write(localStorage.lastname);<br><span class="hljs-comment line-number">11.</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment line-number">12.</span><br><span class="hljs-comment line-number">13.</span>下面的例子对用户访问页面的次数进行计数：<br><span class="hljs-comment line-number">14.</span><br><span class="hljs-comment line-number">15.</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><br><span class="hljs-comment line-number">16.</span><span class="hljs-keyword">if</span> (localStorage.pagecount){<br><span class="hljs-comment line-number">17.</span>  localStorage.pagecount=<span class="hljs-built_in">Number</span>(localStorage.pagecount) +<span class="hljs-number">1</span>;<br><span class="hljs-comment line-number">18.</span>  }<br><span class="hljs-comment line-number">19.</span><span class="hljs-keyword">else</span>{<br><span class="hljs-comment line-number">20.</span>  localStorage.pagecount=<span class="hljs-number">1</span>;<br><span class="hljs-comment line-number">21.</span>  }<br><span class="hljs-comment line-number">22.</span><span class="hljs-built_in">document</span>.write(<span class="hljs-string">"Visits "</span>+ localStorage.pagecount + <span class="hljs-string">" time(s)."</span>);<br><span class="hljs-comment line-number">23.</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment line-number">24.</span><br><span class="hljs-comment line-number">25.</span>sessionStorage - 针对一个 session 的数据存储,当用户关闭浏览器窗口后，数据会被删除。<br><span class="hljs-comment line-number">26.</span><br><span class="hljs-comment line-number">27.</span>创建并访问一个 sessionStorage：<br><span class="hljs-comment line-number">28.</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><br><span class="hljs-comment line-number">29.</span>  sessionStorage.lastname=<span class="hljs-string">"Smith"</span>;<br><span class="hljs-comment line-number">30.</span>  <span class="hljs-built_in">document</span>.write(sessionStorage.lastname);<br><span class="hljs-comment line-number">31.</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment line-number">32.</span><br><span class="hljs-comment line-number">33.</span>下面的例子对用户在当前 session 中访问页面的次数进行计数：<br><span class="hljs-comment line-number">34.</span><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text/javascript"</span>&gt;</span><span class="javascript"><br><span class="hljs-comment line-number">35.</span><span class="hljs-keyword">if</span> (sessionStorage.pagecount){<br><span class="hljs-comment line-number">36.</span>  sessionStorage.pagecount=<span class="hljs-built_in">Number</span>(sessionStorage.pagecount) +<span class="hljs-number">1</span>;<br><span class="hljs-comment line-number">37.</span>  }<br><span class="hljs-comment line-number">38.</span><span class="hljs-keyword">else</span>{<br><span class="hljs-comment line-number">39.</span>  sessionStorage.pagecount=<span class="hljs-number">1</span>;<br><span class="hljs-comment line-number">40.</span>  }<br><span class="hljs-comment line-number">41.</span><span class="hljs-built_in">document</span>.write(<span class="hljs-string">"Visits "</span>+sessionStorage.pagecount+<span class="hljs-string">" time(s) this session."</span>);<br><span class="hljs-comment line-number">42.</span></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-comment line-number">43.</span><br><span class="hljs-comment line-number">44.</span>sessionStorage 、localStorage 和 cookie 之间的区别<br><span class="hljs-comment line-number">45.</span>共同点：都是保存在浏览器端，且同源的。<br><span class="hljs-comment line-number">46.</span><br><span class="hljs-comment line-number">47.</span>区别：cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。<br><span class="hljs-comment line-number">48.</span><br><span class="hljs-comment line-number">49.</span>而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。<br><span class="hljs-comment line-number">50.</span><br><span class="hljs-comment line-number">51.</span>数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。<br><span class="hljs-comment line-number">52.</span><br><span class="hljs-comment line-number">53.</span>作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。<br></code></pre>



<h3 id="问答">问答:</h3>

<ol><li rel="1">自我介绍</li>
<li rel="2">你们使用h5做的登录么，和用native做登录有什么区别?</li>
</ol>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs lsl"><span class="hljs-comment line-number">1.</span>优势：<br><span class="hljs-comment line-number">2.</span>   <span class="hljs-number">1.</span>H5可跨平台使用，开发成本相对更低，一个产品经理+前端+设计+后台就能搞定；App则需适配iOS、安卓等不同平台进行设计和开发，至少需要iOS工程师+Android工程师+PM+前端+设计+后台，开发成本高出<span class="hljs-number">1</span>/<span class="hljs-number">3</span>甚至更多。<br><span class="hljs-comment line-number">3.</span>   <span class="hljs-number">2.</span>H5可随时上线就更新版本，适合快速迭代，且试错成本低。<br><span class="hljs-comment line-number">4.</span>.一个功能做好了立马就能上线，一天更新几十次都毫无压力；App则需要用户主动下载更新，主流的就是iOS，Android、windows仨平台，不同平台运营推广的玩法还不一样，分发和运维成本很高。<br><span class="hljs-comment line-number">5.</span>   <span class="hljs-number">3.</span>而且一个版本的功能出来，虽然很快就能做出其中一部分让内部人员体验。但等我们全部做完了，可能已经过去一周了。然后提交给平台做审核，又要等一阵，再找个好日子发布，三周就过去了。同时，我们如果又做出了更多新的功能，优化了细节，再修复几个bug等等，用户却也只能再等几十天才能体验到。<br><span class="hljs-comment line-number">6.</span>   <span class="hljs-number">4.</span>H5可以轻量的触达用户，提供更便捷的服务。<br><span class="hljs-comment line-number">7.</span>相比在桌面上下一大堆App，在微信的入口或者浏览器上，用户只需点开链接就可以获取我们所提供的服务。有更高的使用时长及导流能力，基于公众号的运营和推广可以快速的触达用户。<br><span class="hljs-comment line-number">8.</span>劣势：<br><span class="hljs-comment line-number">9.</span>   <span class="hljs-number">1.</span>H5—&gt;App的转化强依赖于浏览器，要把用户真正留存在自己的产品中需要进一步的转化；而APP可以内嵌H5，直接在应用内即可打开并与H5进行转化。<br><span class="hljs-comment line-number">10.</span>H5目前基本无法将数据存储在本地，依赖实时性数据，网络状态不好的时候卡到哭。<br><span class="hljs-comment line-number">11.</span>每当用户需要上传数据，比如输入，选择，传照片等，页面的延迟会影响使用的流畅性；而APP可以本地存储，运行速度更快，更省流量，可离线操作或者访问本地资源。<br><span class="hljs-comment line-number">12.</span>H5性能相对较低。<br><span class="hljs-comment line-number">13.</span>   <span class="hljs-number">2.</span>对于复杂的交互，比如<span class="hljs-number">3</span>D特效，频繁的输入输出等等，即使实现了，在用户体验上也要减分。比如在Native App上，一个类似页面滑动切换的效果，基本不会感受到延迟，你手指只要开始滑动，页面就无缝的跟着滑动，但在Web上，大家应该都经常看微信里的各种H5的花哨分享页面吧，那滑动流畅吗？<br><span class="hljs-comment line-number">14.</span>   <span class="hljs-number">3.</span>对于Web App 和 Native App跟H5这三者最终该如何选择，我们还需要考虑，企业的具体产品需求，产品的核心功能，辅助功能，配合运营需求，应用场景等方面的影响。所有的产品都是有了场景才会有体验，针对体验才能有的放矢。再结合他们之间的的优劣情况，我们选择起来就显得比较简单了。<br></code></pre>

<ol start="3"><li rel="3">你们平时开发怎么模拟数据的?</li>
</ol>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs elixir"><span class="hljs-comment line-number">1.</span>如果是小的简单请求的问题,直接在本地创建一个JSON数据,起本地服务就可以了,如果是本地跑通后开始线下测试,后台就会开一测试环境,给你接口(约定数据结构,约定数据字段名称,模拟数据传输场景)<br><span class="hljs-comment line-number">2.</span>一般采用moco数据<br><span class="hljs-comment line-number">3.</span>可以看<span class="hljs-symbol">:http</span><span class="hljs-symbol">://www</span>.jianshu.com/p/dd17342d497b<br></code></pre>

<ol start="4"><li rel="4">你们现在开发主要用了哪些技术?</li>
</ol>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs crmsh"><span class="hljs-comment line-number">1.</span>谁再说HTML,CSS,JS.JQ,<span class="hljs-keyword">node</span> <span class="hljs-title">,vue</span>...那就拜拜了<br><span class="hljs-comment line-number">2.</span>现在用Gulp vue - webpack 搭建项目框架结构,引入各种前端插件等<br><span class="hljs-comment line-number">3.</span>后台使用<span class="hljs-keyword">node</span><span class="hljs-title">环境,以及各种包模块,有很多第三方模块我也没怎么用过,也喜欢琢磨一下<br><span class="hljs-comment line-number">4.</span>或者使用:webpack</span>、react、redux、es6 技术栈等<br></code></pre>

<ol start="5"><li rel="5">用的vue哪个版本? vue的组件之间是如何交互的, 几种方式.</li>
<li rel="6">react之前版本是有双向绑定的，如何实现的？那vue的双向绑定原理呢?</li>
<li rel="7">gulp和webpack之间的区别(也提到了和grunt的区别)</li>
</ol>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs ada"><span class="hljs-comment line-number">1.</span>好多人都问起这个问题,根据我自己使用他俩的情况,我是这么感觉的,这两个构建工具功能上有很多重叠的地方，可以单独使用，也可一起用,如果做一下简单的vue或react的单页应用，webpack也就够用,稍微大型的项目一般俩个一起用.<br><span class="hljs-comment line-number">2.</span>区别的话 <br><span class="hljs-comment line-number">3.</span><span class="hljs-number">1</span>.gulp强调的是前端开发的工作流程，我们可以通过配置一系列的<span class="hljs-keyword">task</span>，定义<span class="hljs-keyword">task</span>处理的事务（例如文件压缩合并、雪碧图、启动server、版本控制等），然后定义执行顺序，来让gulp执行这些<span class="hljs-keyword">task</span>，从而构建项目的整个前端开发流程。核心是 <span class="hljs-keyword">task</span> runner<br><span class="hljs-comment line-number">4.</span><span class="hljs-number">2</span>.webpack是一个前端模块化方案，更侧重模块打包，我们可以把开发中的所有资源（图片、js文件、css文件等）都看成模块，通过loader（加载器）和plugins（插件）对资源进行处理，打包成符合生产环境部署的前端资源。核心是: module bundle<br><span class="hljs-comment line-number">5.</span>我们在gulp进行项目构建的时候，以前策略是将所有js打包为一个文件，所有css打包为一个文件。然后每个页面都将只加载一个js和一个css,也就是我们通常所说的 ==<span class="hljs-keyword">all</span> <span class="hljs-keyword">in</span> one== 打包模式。这样做的目的就是减少http请求。这个方案对于简单的前端项目来说的非常实用。因为通常页面依赖的js,css并不会太大，通过压缩和gzip等方法更加减小了文件的体积。<br><span class="hljs-comment line-number">6.</span>但是随着东西的增多,对性能要求也随之而来,不仅要请求合并，还要按需加载，我要模块化开发，还要自动监听文件更新，支持图片自动合并....<br><span class="hljs-comment line-number">7.</span>对于pc端应用来说，性能往往不是最突出的问题，因为pc端的网速，浏览器性能都有比较好,对于wap端来说，限制于手机的慢网速（仍然有很多用不上<span class="hljs-number">4</span>g，wifi的人），对网站的性能要求就比较苛刻了,最大的问题按需加载和请求合并的权衡。<br><span class="hljs-comment line-number">8.</span>    <span class="hljs-number">1</span>.通过工具分析出前端静态文件依赖表<br><span class="hljs-comment line-number">9.</span>    <span class="hljs-number">2</span>.页面通过模块化工具加载入口文件，并将所依赖的所有文件合并为combo请求。<br><span class="hljs-comment line-number">10.</span>    <span class="hljs-number">3</span>.后端返回combo文件，浏览器将模块缓存起来，跳页面的时候执行步骤<span class="hljs-number">2</span>，只请求没有缓存过的文件。<br><span class="hljs-comment line-number">11.</span>如此通过依赖分析和后端combo实现了按需加载和请求合并。<br><span class="hljs-comment line-number">12.</span>这种实现方式的缺陷就是需要后端的支持，如果前端团队本身不是自己实现的后端路由层，需要后端同学加以配合，就需要更多沟通成本。<br><span class="hljs-comment line-number">13.</span>在没有后端支持的情况下，很难实现按需加载和请求合并。<br><span class="hljs-comment line-number">14.</span>webpack可以说是一个大而全的前端构建工具。它实现了模块化开发和静态文件处理两大问题。<br><span class="hljs-comment line-number">15.</span>我们可以用webpack处理js文件的合并压缩。其他任务也可以交给gulp<br></code></pre>

<ol start="8"><li rel="8">websocket和http协议之间的区别?</li>
</ol>



<pre class="prettyprint with-line-number hljs-light"><code class="hljs livecodeserver"><span class="hljs-comment line-number">1.</span>HTTP协议为单向协议，即浏览器只能向服务器请求资源，服务器才能将数据传送给浏览器，而服务器不能主动向浏览器传递数据。分为长连接和短连接，短连接是每次<span class="hljs-keyword">http</span>请求时都需要三次握手才能发送自己的请求，每个request对应一个response；长连接是短时间内保持连接，保持TCP不断开，指的是TCP连接。<br><span class="hljs-comment line-number">2.</span><br><span class="hljs-comment line-number">3.</span>WebSocket解决客户端发起多个<span class="hljs-keyword">http</span>请求到服务器资源浏览器必须要经过长时间的轮询问题。<br><span class="hljs-comment line-number">4.</span>一种双向通信协议，在建立连接后，WebSocket服务器和Browser/UA都能主动的向对方发送或接收数据，就像Socket一样，不同的是WebSocket是一种建立在Web基础上的一种简单模拟Socket的协议；     <br><span class="hljs-comment line-number">5.</span>WebSocket需要通过握手连接，类似于TCP它也需要客户端和服务器端进行握手连接，连接成功后才能相互通信。<br><span class="hljs-comment line-number">6.</span>WebSocket在建立握手连接时，数据是通过<span class="hljs-keyword">http</span>协议传输的，“GET/chat HTTP/<span class="hljs-number">1.1</span>”，这里面用到的只是<span class="hljs-keyword">http</span>协议一些简单的字段。但是在建立连接之后，真正的数据传输阶段是不需要<span class="hljs-keyword">http</span>协议参与的。<br><span class="hljs-comment line-number">7.</span><br><span class="hljs-comment line-number">8.</span><span class="hljs-built_in">socket</span>是对TCP/IP协议的封装，本身并不是协议，而是一个调用接口(API)，通过Socket，我们才能使用TCP/IP。<br><span class="hljs-comment line-number">9.</span>四层，分别为应用层（Telnet、FTP和Email等）、运输层（TCP、UDP）、网络层（IP、ICMP、IGMP等）和链路层（设备驱动程序）<br><span class="hljs-comment line-number">10.</span>三次握手完毕后，客户端与服务器才正式开始传送数据<br><span class="hljs-comment line-number">11.</span>四次挥手后断开连接<br><span class="hljs-comment line-number">12.</span>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认<br><span class="hljs-comment line-number">13.</span>TCP：面向连接，通过三次握手建立连接，通讯完成时要拆除连接，只能端到端传输<br></code></pre>

<ol start="9"><li rel="9">你了解过闭包么？</li>
<li rel="10">你有什么想问我的么</li>
</ol>

<h3 id="二面">二面:</h3>

<ol><li rel="1">输入url，页面展示出来，用的什么协议? http协议属于那一层? 7层。</li>
<li rel="2">进程和线程的区别.</li>
<li rel="3">从输入一个url，到也没展示，中间发生了什么?</li>
<li rel="4">秒杀时，如何保证当库存只剩下10个的时候， 能正常分配?</li>
<li rel="5">让你来设计的话，如何能把表单安全的提交过去。</li>
<li rel="6">线上代码经常更新，再次上线的时候，如何保证代码是新的，？不读缓存</li>
</ol></div></body></html>