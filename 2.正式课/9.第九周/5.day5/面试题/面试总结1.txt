前端有哪些页面优化方法?
减少 HTTP请求数
从设计实现层面简化页面
合理设置 HTTP缓存
资源合并与压缩
合并 CSS图片，减少请求数的又一个好办法。
将外部脚本置底（将脚本内容在页面信息内容加载后再加载）
多图片网页使用图片懒加载。
在js中尽量减少闭包的使用
尽量合并css和js文件
尽量使用字体图标或者SVG图标，来代替传统的PNG等格式的图片
减少对DOM的操作
在JS中避免“嵌套循环”和 “死循环”
尽可能使用事件委托（事件代理）来处理事件绑定的操作


vue使用webpack打包部署到服务器上页面空白什么原因
（因为index.html里边的内容都是通过script标签引入的，而你的路径不对，打开肯定是空白的。
解决办法：vue.config.js下的assetsPublicPath默认的是  ‘/’  也就是根目录。而我们的index.html和static在同一级目录下面。  所以要改为  ‘./ ’;
再次执行 npm run build 就可以了。 创建的项目一般没有这个文件，需要我们自己来配置）


vuex中action有什么作用（action是一个异步函数，把异步的方法写在action中 通过commit提交到mutations 进行修改数据）


url按下后发生了什么（按下后 先根据url进行DNS解析 来找到对应的服务器IP 然后跟服务器进行TCP连接（这时候会进行三次握手）找到对应的资源库，根据资源库返回的页面信息来执行自身的解析机制 最后服务器将解析的信息返回给客户端（四次挥手））


ajax中get和post请求的区别
get 一般用于获取数据
get请求如果需要传递参数，那么会默认将参数拼接到url的后面；然后发送给服务器；
get请求传递参数大小是有限制的；是浏览器的地址栏有大小限制；
get安全性较低
get 一般会走缓存，为了防止走缓存，给url后面每次拼的参数不同；放在?后面，一般用个时间戳
post 一般用于发送数据
post传递参数，需要把参数放进请求体中，发送给服务器；
post请求参数放进了请求体中，对大小没有要求；
post安全性比较高；
post请求不会走缓存； 


es6新特性 数组去重（set和from  map和filter）


防抖节流 （防抖：鼠标划上时会一直跳动，节流：鼠标划上时会定时跳动一下）


重绘 回流 （回流：页面中的元素增删改的时候会引起其他元素的变动，重绘：页面中修改元素颜色，字体大小的时候，页面会进行重新渲染）


vue的指令 （v-el（提供一个在页面上已存在的 DOM 元素作为 Vue 实例的挂载目标.可以是 CSS 选择器，也可以是一个 HTMLElement 实例,）） 



vue生命周期
beforeCreate阶段：vue实例的挂载元素el和数据对象data都是undefined，还没有初始化。
created阶段：vue实例的数据对象data有了，可以访问里面的数据和方法，未挂载到DOM，el还没有
beforeMount阶段：vue实例的el和data都初始化了，但是挂载之前为虚拟的dom节点
mounted阶段：vue实例挂载到真实DOM上，就可以通过DOM获取DOM节点
beforeUpdate阶段：响应式数据更新时调用，发生在虚拟DOM打补丁之前，适合在更新之前访问现有的DOM，比如手动移除已添加的事件监听器
updated阶段：虚拟DOM重新渲染和打补丁之后调用，组成新的DOM已经更新，避免在这个钩子函数中操作数据，防止死循环
beforeDestroy阶段：实例销毁前调用，实例还可以用，this能获取到实例，常用于销毁定时器，解绑事件
destroyed阶段：实例销毁后调用，调用后所有事件监听器会被移除，所有的子实例都会被销毁



vue组件之间的传参（props  $parent  $children  $emit）



如何让一个div水平垂直居中
div {
position: relative / fixed; /* 相对定位或绝对定位均可 */
width:500px;
height:300px;
top: 50%;
left: 50%;
margin-top:-150px;
margin-left:-250px;
 外边距为自身宽高的一半 */
background-color: pink; /* 方便看效果 */
 }

.container {
display: flex;
align-items: center; /* 垂直居中 */
justify-content: center; /* 水平居中 */
 
}



vuex的组成（state状态  action动作 type）


Vue的组件之间是如何传递的？
父传子:
把父组件的数据作为子组件的动态属性传递给子组件
在子组件中，用props来接收属性名的属性值
在子组件中使用动态的属性名，就获取到父组件传递的数据；
子传父:
子组件想改变父组件，利用了发布订阅的方式；
兄弟相邻之间传递：
事件车可以订阅和发布方法；就是一个Vue的实例；
把当前要传递的数据通过事件车的订阅方法，那么另一个组件就可以获取对应的数据；



js中跨域方法
通过jsonp跨域
通过修改document.domain来跨子域
使用window.name来进行跨域
使用HTML5中新引进的window.postMessage方法来跨域传送数据



es6的新特性都有哪些？
let定义块级作用域变量
没有变量的提升，必须先声明后使用
let声明的变量，不能与前面的let，var，conset声明的变量重名
const 定义只读变量
const声明变量的同时必须赋值，const声明的变量必须初始化，一旦初始化完毕就不允许修改
const声明变量也是一个块级作用域变量
const声明的变量没有“变量的提升”，必须先声明后使用
const声明的变量不能与前面的let， var ， const声明的变量重
const定义的对象\数组中的属性值可以修改,基础数据类型不可以
ES6可以给形参函数设置默认值
在数组之前加上三个点（...）展开运算符
数组的解构赋值、对象的解构赋值
箭头函数的特点
箭头函数相当于匿名函数，是不能作为构造函数的，不能被new
箭头函数没有arguments实参集合,取而代之用...剩余运算符解决
箭头函数没有自己的this。他的this是继承当前上下文中的this
箭头函数没有函数原型
箭头函数不能当做Generator函数，不能使用yield关键字
不能使用call、apply、bind改变箭头函数中this指向
Set数据结构，数组去重



computed 和watch的区别：
computed
computed是不支持异步；
computed会走缓存
多对一
watch
支持异步；
不走缓存
一对多



脑筋急转弯   

桥长80米 桥头有无数豆子 走一米要吃一个豆子 每次最多带60个豆子 问走过桥需要多少豆子 （最少120个豆子）