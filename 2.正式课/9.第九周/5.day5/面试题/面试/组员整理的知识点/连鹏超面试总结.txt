1、什么是防抖和节流？有什么区别？如何实现？
 防抖：触发高频事件后n秒内函数只会执行一次，如果n秒内高频事件再次被触发，则重新计算时间
 思路：
         每次触发事件时都取消之前的延时调用方法
 节流：高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率
 思路：
         每次触发事件时都判断当前是否有等待执行的延时函数

2、介绍下重绘和回流（Repaint & Reflow），以及如何进行优化
 重绘
由于节点的几何属性发生改变或者由于样式发生改变而不会影响布局的，称为重绘，例如outline, visibility, color、background-color等，重绘的代价是高昂的，因为浏览器必须验证DOM树上其他节点元素的可见性。

回流
回流是布局或者几何属性需要改变就称为回流。回流是影响浏览器性能的关键因素，因为其变化涉及到部分页面（或是整个页面）的布局更新。一个元素的回流可能会导致了其所有子元素以及DOM中紧随其后的节点、祖先节点元素的随后的回流。

3、call 和 apply 的区别是什么，哪个性能更好一些
两者区别在参数传递格式：
apply( )：两个参数，第一个是运行函数的作用域，第二个是参数数组（可以是array的实例，或者arguments对象）。
call( )：参数个数不定，第一个是运行函数的作用域，其余传递给函数的参数逐个列出。
apply()和 call()的2个作用：给函数传参、扩充作用域；
至于是使用 apply( )还是 call( )，完全取决于你采取哪种给函数传递参数的方式最方便。

4、怎么让一个 div 水平垂直居中
   display: flex;
    justify-content: center;
    align-items: center;

div.parent {
    position: relative; 
}
div.child {
    position: absolute; 
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);  
}

div.child {
    width: 50px;
    height: 10px;
    position: absolute;
    left: 0;
    top: 0;
    right: 0;
    bottom: 0;
    margin: auto;
}

div.child {
    width: 50px;
    height: 10px;
    position: absolute;
    top: 50%;
    left: 50%;
    margin-left: -25px;
    margin-top: -5px;
}

5、分析比较 opacity: 0、visibility: hidden、display: none 优劣和适用场景

   display: none (不占空间，不能点击)（场景，显示出原来这里不存在的结构）
   visibility: hidden（占据空间，不能点击）（场景：显示不会导致页面结构发生变动，不会撑开）
   opacity: 0（占据空间，可以点击）（场景：可以跟transition搭配）

6、Vue 的父组件和子组件生命周期钩子执行顺序是什么

加载渲染过程
父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted
子组件更新过程
父beforeUpdate->子beforeUpdate->子updated->父updated
父组件更新过程
父beforeUpdate->父updated
销毁过程
父beforeDestroy->子beforeDestroy->子destroyed->父destroyed

7、var、let 和 const 区别的实现原理是什么

var 和 let 用以声明变量，const 用于声明只读的常量；

var 声明的变量，不存在块级作用域，在全局范围内都有效，let 和 const 声明的，只在它所在的代码块内有效；

let 和 const 不存在像 var 那样的 “变量提升” 现象，所以 var 定义变量可以先使用，后声明，而 let 和 const 只可先声明，后使用；

let 声明的变量存在暂时性死区，即只要块级作用域中存在 let，那么它所声明的变量就绑定了这个区域，不再受外部的影响。

let 不允许在相同作用域内，重复声明同一个变量；

const 在声明时必须初始化赋值，一旦声明，其声明的值就不允许改变，更不允许重复声明；

8、渐进增强 VS 优雅降级

渐进增强（Progressive Enhancement）：一开始就针对低版本浏览器进行构建页面，完成基本的功能，然后再针对高级浏览器进行效果、交互、追加功能达到更好的体验。

优雅降级（Graceful Degradation）：一开始就构建站点的完整功能，然后针对浏览器测试和修复。比如一开始使用 CSS3 的特性构建了一个应用，然后逐步针对各大浏览器进行 hack 使其可以在低版本浏览器上正常浏览。

9、函数闭包

闭包就是函数执行产生一个私有的作用域（不销毁），在这个作用域中的私有变量和外界互不干扰，而且作用域（栈）不销毁，这些私有变量存储的值也都保存下来了，所以整体来说闭包就是为了保护和保存变量的 实际项目开发中，很多地方使用到了闭包，例如：

循环事件绑定，在之前由于事件编程是异步编程的，我们经常使用的方法就是在循环的时候把索引存储起来（可以基于自定义属性存储，也可以基于闭包存储），后期需要使用的时候，向上级作用域查找使用即可，我之前在学习资料上了解了柯理化思想，它其实也是基于闭包完成的，像bind的实现，和redux中的reducer合并的源码中也是基于柯理化思想实现的，还有很多地方也应用到了闭包，但是闭包比较占内存，我会尽量减少对它的使用，但是有写需求必须要用

10、详解vue生命周期

beforeCreate
created
beforeMount
mounted
beforeUpdate
updated
beforeDestroy
destroyed

11、document.ready和window.onload的区别

页面加载完成有两种事件，一是ready，表示文档结构已经加载完成（不包含图片等非文字媒体文件），二是onload，指示页面包含图片等文件在内的所有元素都加载完成。

12、vue-router钩子函数生命周期

钩子函数总体上分为两大类：

全局的钩子函数
组件的钩子函数

全局钩子函数有2个：

beforeEach：在路由切换开始时调用
afterEach：在每次路由切换成功进入激活阶段时被调用

组件的钩子函数一共6个：

data：可以设置组件的data
activate：激活组件
deactivate：禁用组件
canActivate：组件是否可以被激活
canDeactivate：组件是否可以被禁用
canReuse：组件是否可以被重用

13、图片懒加载

将页面中的img标签src指向一张小图片或者src为空，然后定义data-src（这个属性可以自定义命名，我才用data-src）属性指向真实的图片。src指向一张默认的图片，否则当src为空时也会向服务器发送一次请求。


14、vue 中 v-if 和 v-show 的区别

v-if 当值为 true时，显示div ，当值为false时，改元素消失，代码也会消失，相当于将代码删除了，当在为true时，页面会重新渲染div; 
而v-show 控制的隐藏出现，只是将css属性设为了display：none 或block;
































