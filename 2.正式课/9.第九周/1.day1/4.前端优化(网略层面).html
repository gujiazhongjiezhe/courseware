<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <script>
    /* 
    产品性能优化方面
      http网络层优化
      代码编译层优化webpack
      代码运行层优化html/css/js/vue/react
      安全优化 xss+csrf
      数据埋点以及心能优化


      今天咱们讲输入url，浏览器到底了什么

      第一步：url解析
      第二步：缓存检查
        缓存位置：
            + Memory Cache：内存缓存(内存条中，当前页面关闭就没了，临时缓存)
            + Disk Cache：硬盘缓存
        打开网页：查找disk cache中是否有匹配，如果有则使用，如果没有则发送网络请求

        普通刷新(F5):因为页面没有关闭，因此Memory Cache时候可以用的，会被优先使用，其次才是Disk Cache
        强制刷新(ctrl+f5)：浏览器不使用缓存，因此发送的请求头会带有
        cache-control：no-cache(为了兼容，还带了pragma：no-cache)，服务器直接返回200和最新的内容


        缓存的两种形式：强缓存和协商缓存(是对强缓存的一种辅助，强缓存生效的时候，走的是强缓存，强缓存失效或者没有才会去看协商缓存)

            强缓存：http1.0(Expires) http1.1(Cache-control)有一个过期的时间
                服务器设定了一些"资源(静态资源 /css/js/图片...)"的强制缓存机制，在浏览器缓存的有效期内，我们除了清缓存刷新，正常加载页面都是从缓存中获取数据，不是从服务器重新获取
                    + 优势：减少对服务器的请求。资源加载更快，页面渲染的也更快
                    + 弊端：当我们的资源在服务器更新了，但是跟本地还是有缓存的，这样会导致客户端无法及时获取最新的内容
                        + HTML页面不做缓存，每一次重新发布资源的时候，资源内容是更新的，资源文件的名字也会变【基于webpack设置名字的hash】，这样页面请求的资源文件也就变了，客户端没有做过和这个新文件的缓存，还是从服务器获取
                        + 哪怕文件名字不变，只要请求资源文件的后面加一个时间戳也可以，这样get请求就不会走缓存【index.css?_=133534344】

                        + 不做强缓存的设置，基于协商缓存实现【真实项目中往往是两者同时设置的】

            协商缓存：Last-Modified(http1.0/If-Modified-Since)   ETag(http1.1/If-None-Match)
                协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识来决定是否使用缓存的过程

                【强缓存】不在向服务器发起请求；【协商缓存】哪怕本地有缓存也要想服务器发送请求(校验资源文件是否被更新)
                    + 有更改就从服务器拿回来最新的资源在存储到本地做缓存处理
                    + 如果没有更改，服务器啥都不返回客户端在从本地读取缓存信息

        ETag存储的是标识，Last-Modified存储的是时间，时间的但是精确到秒，所以如果是毫秒内更新了文件，那他是识别不出来的，但是用eTag就没问题


        // 那如果是数据类型的能不能够走缓存呢，可以，但是用的不多
            + 利用localstorage通过手动存储信息
                + 第一次请求数据之后把请求来的数据和时间记录到本地存储中，以后再重新请求的时候看看本地有没有，和看看有没有过期，如果没有过期，那就使用本地的，如果过期了那就重新请求，把最新的数据和时间在重新存储

            
        第三步：DNS域名解析：DNS服务器去解析域名：就是根据浏览器识别出来的url中的域名找到对应的ip地址，在通过ip找到对应的服务器的过程
            当然DNS解析也是有缓存的，浏览器解析一次，一般都会在本地记录一下解析记录
            优化手段：
            + 减少dns请求次数(少用不一样的域名)【不现实】
            + 在这里做DNS预解析 <link rel="dns-perfetch" fref="xxx">
            
        

      

     */

     let a = 100;
     let b = 200;

      [b,a] = [a,b];
      console.log(a,b);
      
  </script>
</body>
</html>